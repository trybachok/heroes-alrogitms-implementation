## Реализация метода `GeneratePreset.generate`

Метод формирует армию компьютера на основе списка типов юнитов с учётом ограничений по суммарной стоимости (`maxPoints`) и количеству юнитов каждого типа (не более 11). Для подбора состава используется жадный алгоритм, ориентированный на максимальную эффективность армии.

На первом этапе типы юнитов сортируются по эффективности. В качестве основного критерия используется отношение атаки к стоимости (`baseAttack / cost`), при равенстве — отношение здоровья к стоимости (`health / cost`). Дополнительно учитывается стоимость юнита, чтобы более эффективно использовать оставшиеся очки. Сравнение выполняется без использования вещественных чисел, что позволяет избежать ошибок округления.

После сортировки метод последовательно добавляет максимальное возможное количество юнитов каждого типа, не превышая лимит в 11 юнитов на тип и доступный бюджет очков. Затем выполняется дополнительный проход для добора юнитов на оставшиеся очки при сохранении всех ограничений.

Контроль ограничений реализован с помощью счётчика количества юнитов по типам, а контроль бюджета — через учёт оставшихся доступных очков.

### Алгоритмическая сложность

Пусть `n` — количество типов юнитов, `m` — итоговое количество юнитов в армии.

1. **Сортировка типов юнитов**: Выполняется за **O(n log n)**.
2. **Первый проход (основной набор)**: Метод итерируется по отсортированному списку типов (`n` итераций). Внутри каждой итерации вычисляется максимально возможное количество юнитов данного типа для покупки (константное время) и выполняется цикл добавления этих юнитов. Суммарно во всех итерациях будет добавлено не более `m` юнитов. Сложность: **O(n + m)**.
3. **Второй проход (добор)**: В худшем случае выполняется несколько итераций по списку типов, пока бюджет не будет исчерпан или не будут достигнуты лимиты. Так как каждый успешный шаг добавляет юнит, общее количество добавлений ограничено `m`, а количество типов — `n`. Сложность: **O(n + m)**.

**Итоговая сложность**: **O(n log n + m)**.
Учитывая, что `m` (количество юнитов) ограничено `11 * n` (согласно ТЗ), итоговая сложность может быть представлена как **O(n log n)**.

**Потребление памяти**: **O(n)** для хранения списка типов и счетчиков.

-------------

## Реализация метода `SimulateBattle.simulate`

Метод выполняет симуляцию боя между армией игрока и армией компьютера в виде последовательности раундов, строго следуя правилам, заданным в техническом задании.

В начале каждого раунда из живых юнитов обеих армий формируются очереди ходов, отсортированные по убыванию значения базовой атаки. Это обеспечивает приоритет хода для наиболее сильных юнитов. Ходы в раунде выполняются поочерёдно между армиями. Если у одной из армий в текущем раунде заканчиваются юниты, она ожидает завершения ходов противника.

Во время хода юнит выполняет атаку с помощью метода `unit.getProgram().attack()`, который возвращает цель атаки или `null`. После каждой атаки выводится лог боя через `printBattleLog.printBattleLog(attacker, target)`. Если цель погибает до своего хода, она немедленно удаляется из очереди ходов текущего раунда, что приводит к пересчёту очередности.

Раунд завершается, когда все доступные юниты совершили ход или погибли. Симуляция боя полностью прекращается, когда у одной из армий не остаётся живых юнитов, способных атаковать.

### Алгоритмическая сложность

Пусть `n` — общее количество юнитов в обеих армиях.

1. **Внешний цикл (раунды)**: Бой продолжается до победы одной из сторон. Количество раундов зависит от характеристик юнитов (здоровье, атака).
2. **Построение очередей (TreeSet)**: В начале каждого раунда выполняется добавление всех живых юнитов в `TreeSet`. Каждая вставка занимает `O(log n)`. Итого для `n` юнитов: **O(n log n)**.
3. **Игровой цикл раунда**:
    - Выбор юнита (`pollFirst`): **O(log n)**.
    - Выполнение атаки: Если предположить, что поиск пути и атака занимают константное время (или фиксированное время для сетки), то **O(1)**.
    - Удаление погибшего юнита из очереди защитника: Поиск в `IdentityHashMap` занимает **O(1)**, удаление из `TreeSet` занимает **O(log n)**.
4. Всего в раунде происходит `n` ходов. Сложность одного раунда: **O(n log n)**.

**Итоговая сложность**: **O(R * n log n)**, где `R` — количество раундов. В худшем случае (когда за раунд погибает хотя бы один юнит) `R` пропорционально `n`, что дает **O(n² log n)**.

-------------

## Реализация метода `SuitableForAttackUnitsFinder.getSuitableUnits`

Метод определяет список юнитов противника, которые могут быть выбраны целью атаки, чтобы исключить заведомо невозможные попытки поиска пути и атаки.

Входные данные представлены в виде списка рядов (`unitsByRow`), где каждый ряд содержит юниты противника, расположенные на одной координате по оси `x`. Количество рядов фиксировано и равно трём.

Логика выбора целей зависит от параметра `isLeftArmyTarget`:
- если значение `true`, атаке подвергается левая армия (армия компьютера), и в каждом ряду выбирается юнит с минимальным значением координаты `y`, то есть не закрытый слева другими юнитами;
- если значение `false`, атаке подвергается правая армия (армия игрока), и в каждом ряду выбирается юнит с максимальным значением координаты `y`, то есть не закрытый справа.

Таким образом, в каждом ряду выбирается не более одного подходящего юнита — крайний со стороны атакующего.

### Алгоритмическая сложность

Пусть `n` — общее количество юнитов во всех рядах.

1. **Внешний цикл**: Итерируется по списку рядов. Количество рядов — 3.
2. **Внутренний цикл**: Итерируется по всем юнитам в конкретном ряду.
3. В процессе прохода выполняется сравнение координаты `y` (константная операция).

**Итоговая сложность**: **O(n)**, так как метод совершает ровно один проход по всем юнитам.
**Дополнительная память**: **O(1)** (не считая возвращаемого списка, размер которого ограничен количеством рядов).

-------------

## Реализация метода `UnitTargetPathFinder.getTargetPath`

Метод находит кратчайший маршрут на игровом поле между атакующим юнитом и целью и возвращает его в виде списка `Edge` (координат клеток пути) **от стартовой клетки до клетки цели включительно**. Если маршрут построить невозможно, метод возвращает пустой список.

Поле рассматривается как граф: каждая клетка — вершина, переход в соседнюю клетку — ребро. В качестве препятствий используются клетки, занятые юнитами из `existingUnitList` (кроме `attackUnit` и `targetUnit`). Движение разрешено в 8 направлениях, включая диагонали.

Для поиска пути применяется алгоритм **A\*** (A-star), так как он эффективно находит кратчайший путь на сетке с препятствиями. В качестве эвристики используется **Chebyshev distance** (`max(|dx|, |dy|)`), которая корректна при диагональном движении и не завышает реальную стоимость, поэтому сохраняет оптимальность найденного маршрута.

### Алгоритмическая сложность

Пусть `V = WIDTH * HEIGHT` — количество клеток на поле (в данной реализации 27 * 21 = 567).

1. **Построение карты препятствий**: Проход по списку юнитов `existingUnitList` (размером `n`) и установка флагов в массиве. Сложность: **O(n)**. Поскольку `n <= V`, это **O(V)**.
2. **Алгоритм A***:
    - В худшем случае посещаются все клетки поля: **O(V)** итераций.
    - В каждой итерации выполняются операции с приоритетной очередью (`poll` и `add`). Сложность операций: **O(log V)**.
    - Проверка 8 соседей для каждой клетки: **O(1)**.
3. **Восстановление пути**: Проход по цепочке предков от цели до старта. В худшем случае длина пути — **O(V)**.

**Итоговая сложность**: **O(V log V)**.
**Дополнительная память**: **O(V)** для хранения карты препятствий, массива посещенных вершин и приоритетной очереди.


